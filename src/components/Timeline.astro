---
import { Icon } from 'astro-icon/components'

type TimelineEvent =
  | {
      type: 'experience'
      title: string
      company: string
      location: string
      startDate: string
      endDate: string
      description: string
    }
  | {
      type: 'education'
      institution: string
      degree: string
      startDate: string
      endDate: string
      description: string
    }
  | {
      type: 'achievement'
      title: string
      issuer: string
      date: string
      description: string
    }
  | {
      type: 'speaking'
      title: string
      venue: string
      date: string
      links: {
        info?: string
        repo?: string
        recording?: string
        twitter?: string
      }
    }
  | {
      type: 'personal'
      title: string
      date: string
      description?: string
    }

interface Props {
  items: TimelineEvent[]
}

const { items } = Astro.props

const slugify = (str: string): string => {
  return str
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .trim()
}

const getItemId = (item: TimelineEvent, index: number): string => {
  switch (item.type) {
    case 'experience':
      return `exp-${slugify(item.company)}-${slugify(item.startDate)}`
    case 'education':
      return `edu-${slugify(item.institution)}-${slugify(item.startDate)}`
    case 'achievement':
      return `award-${slugify(item.title)}-${slugify(item.date)}`
    case 'speaking':
      return `talk-${slugify(item.title.slice(0, 40))}-${slugify(item.date)}`
    case 'personal':
      return `personal-${slugify(item.title)}-${slugify(item.date)}`
  }
}

const getNodeColor = (type: TimelineEvent['type']) => {
  switch (type) {
    case 'experience':
      return '#3b82f6' // blue-500
    case 'education':
      return '#22c55e' // green-500
    case 'achievement':
      return '#f59e0b' // amber-500
    case 'speaking':
      return '#a855f7' // purple-500
    case 'personal':
      return '#ec4899' // pink-500
  }
}

const getNodeIcon = (type: TimelineEvent['type']) => {
  switch (type) {
    case 'experience':
      return 'lucide:briefcase'
    case 'education':
      return 'lucide:graduation-cap'
    case 'achievement':
      return 'lucide:award'
    case 'speaking':
      return 'lucide:presentation'
    case 'personal':
      return 'lucide:heart'
  }
}

const getNodeLabel = (type: TimelineEvent['type']) => {
  switch (type) {
    case 'experience':
      return 'Experience'
    case 'education':
      return 'Education'
    case 'achievement':
      return 'Honours'
    case 'speaking':
      return 'Speaking'
    case 'personal':
      return 'Personal'
  }
}
---

<style>
  .timeline-item:target,
  .timeline-item.is-anchored {
    background-color: rgba(200, 200, 200, 0.08);
  }

  .dark .timeline-item:target,
  .dark .timeline-item.is-anchored {
    background-color: rgba(100, 100, 100, 0.05);
  }

  .timeline-node-link:hover .timeline-node-circle {
    transform: scale(1.15);
  }

  .timeline-node-outer-ring {
    opacity: 0;
  }

  .timeline-item:target .timeline-node-outer-ring,
  .timeline-item.is-anchored .timeline-node-outer-ring {
    opacity: 0.15;
  }
</style>

<!-- Filter and mode toggles -->
<div class="mb-8 flex justify-between items-start flex-wrap gap-4">
  <div class="flex gap-2 flex-wrap items-center">
    {
      (['experience', 'education', 'achievement', 'speaking', 'personal'] as const).map((eventType) => (
        <button
          type="button"
          class="timeline-filter px-2 py-1 rounded text-xs transition-opacity flex items-center gap-1.5"
          data-type={eventType}
        >
          <Icon name={getNodeIcon(eventType)} class="w-2.5 h-2.5" />
          {getNodeLabel(eventType)}
        </button>
      ))
    }
    <button
      type="button"
      id="filter-help"
      class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
      aria-label="Show filter help"
    >
      <Icon name="lucide:help-circle" class="w-3.5 h-3.5" />
    </button>
  </div>
  <button
    type="button"
    id="time-scale-toggle"
    class="px-2 py-1 rounded text-xs opacity-40 hover:opacity-100 transition-opacity flex items-center gap-1.5"
  >
    <Icon name="lucide:ruler" class="w-2.5 h-2.5" />
    Time Scale
  </button>
</div>

<!-- Help overlay (hidden by default) -->
<div
  id="filter-help-overlay"
  class="hidden fixed inset-0 bg-black/20 dark:bg-black/40 z-40"
  style="display: none;"
>
  <div
    class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white dark:bg-gray-900 rounded-lg shadow-xl p-6 max-w-md z-50 border border-gray-200 dark:border-gray-700"
  >
    <div class="flex justify-between items-start mb-4">
      <h3 class="text-lg font-semibold text-gray-900 dark:text-gray-100">Timeline Filters</h3>
      <button
        id="filter-help-close"
        class="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 transition-colors"
      >
        <Icon name="lucide:x" class="w-5 h-5" />
      </button>
    </div>
    <div class="space-y-3 text-sm text-gray-700 dark:text-gray-300">
      <p><strong>Click</strong> a filter button to toggle that category on/off</p>
      <p><strong>Alt+Click</strong> a filter button to show only that category</p>
      <p>
        <strong>Time Scale</strong> toggles between evenly-spaced and chronologically-accurate layout (1 pixel
        = 1 day)
      </p>
    </div>
  </div>
</div>

<div class="relative">
  <!-- SVG Timeline -->
  <svg class="absolute left-0 top-0 h-full w-full pointer-events-none" aria-hidden="true" id="timeline-svg">
    <g class="timeline-lines-mobile sm:hidden">
      {
        items.map((item, index) => {
          if (index < items.length - 1) {
            return (
              <line
                x1="96"
                y1={index * 180 + 24}
                x2="96"
                y2={(index + 1) * 180 + 24}
                class="timeline-line stroke-gray-200 dark:stroke-gray-800"
                stroke-width="1"
                data-type={item.type}
                data-index={index}
              />
            )
          }
        })
      }
      <!-- Final line extending to bottom -->
      <line
        x1="96"
        y1={(items.length - 1) * 180 + 24}
        x2="96"
        y2={(items.length - 1) * 180 + 24 + 800}
        class="timeline-line stroke-gray-200 dark:stroke-gray-800"
        stroke-width="1"
        opacity="0.5"></line>
    </g>
    <g class="timeline-lines-sm hidden sm:block md:hidden">
      {
        items.map((item, index) => {
          if (index < items.length - 1) {
            return (
              <line
                x1="116"
                y1={index * 180 + 24}
                x2="116"
                y2={(index + 1) * 180 + 24}
                class="timeline-line stroke-gray-200 dark:stroke-gray-800"
                stroke-width="1"
                data-type={item.type}
                data-index={index}
              />
            )
          }
        })
      }
      <!-- Final line extending to bottom -->
      <line
        x1="116"
        y1={(items.length - 1) * 180 + 24}
        x2="116"
        y2={(items.length - 1) * 180 + 24 + 800}
        class="timeline-line stroke-gray-200 dark:stroke-gray-800"
        stroke-width="1"
        opacity="0.5"></line>
    </g>
    <g class="timeline-lines-md hidden md:block">
      {
        items.map((item, index) => {
          if (index < items.length - 1) {
            return (
              <line
                x1="188"
                y1={index * 180 + 24}
                x2="188"
                y2={(index + 1) * 180 + 24}
                class="timeline-line stroke-gray-200 dark:stroke-gray-800"
                stroke-width="1"
                data-type={item.type}
                data-index={index}
              />
            )
          }
        })
      }
      <!-- Final line extending to bottom -->
      <line
        x1="188"
        y1={(items.length - 1) * 180 + 24}
        x2="188"
        y2={(items.length - 1) * 180 + 24 + 800}
        class="timeline-line stroke-gray-200 dark:stroke-gray-800"
        stroke-width="1"
        opacity="0.5"></line>
    </g>
  </svg>

  {
    items.map((item, index) => {
      const isSingleDate = item.type === 'achievement' || item.type === 'speaking' || item.type === 'personal'
      const startDate = isSingleDate ? item.date : item.startDate
      const endDate = isSingleDate ? null : item.endDate === 'Present' ? null : item.endDate
      const itemId = getItemId(item, index)
      const nodeColor = getNodeColor(item.type)

      return (
        <div
          id={itemId}
          class="timeline-item relative grid grid-cols-[80px_auto] sm:grid-cols-[100px_auto] md:grid-cols-[140px_auto] gap-4 sm:gap-6 md:gap-8 pb-12 last:pb-0 scroll-mt-8 -ml-4 pl-4 py-4 rounded transition-colors"
          data-type={item.type}
          style={`min-height: 180px`}
        >
          {/* Date on left */}
          <div class="text-right text-sm text-gray-700 dark:text-gray-400 pt-2 sm:whitespace-nowrap">
            <span class="inline-block">{startDate}</span>
            {endDate && (
              <>
                <span class="hidden sm:inline"> - </span>
                <span class="inline-block">{endDate}</span>
              </>
            )}
          </div>

          {/* Timeline node and content */}
          <div class="relative pl-10">
            {/* SVG Node */}
            <a
              href={`#${itemId}`}
              class="timeline-node-link absolute left-0 -top-2 pointer-events-auto"
              aria-label={`Jump to ${item.type === 'experience' ? item.company : item.type === 'education' ? item.institution : item.type === 'achievement' ? item.title : item.title}`}
            >
              <svg
                width="32"
                height="32"
                viewBox="0 0 32 32"
                class="timeline-node-circle transition-transform"
              >
                <circle
                  cx="16"
                  cy="16"
                  r="14"
                  fill={nodeColor}
                  class="timeline-node-outer-ring transition-opacity"
                />
                <circle cx="16" cy="16" r="8" fill={nodeColor} />
              </svg>
            </a>

            {/* Content */}
            <div class="-mt-2">
              {item.type === 'experience' && (
                <>
                  <div class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-1">{item.title}</div>
                  <div class="text-sm text-gray-600 dark:text-gray-400 opacity-60 mb-2">@ {item.company}</div>
                  {item.description && (
                    <p class="text-sm text-gray-700 dark:text-gray-300 opacity-80">{item.description}</p>
                  )}
                </>
              )}

              {item.type === 'education' && (
                <>
                  <div class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-1">{item.degree}</div>
                  <div class="text-sm text-gray-600 dark:text-gray-400 opacity-60 mb-2">
                    @ {item.institution}
                  </div>
                  {item.description && (
                    <p class="text-sm text-gray-700 dark:text-gray-300 opacity-80">{item.description}</p>
                  )}
                </>
              )}

              {item.type === 'achievement' && (
                <>
                  <div class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-1">{item.title}</div>
                  <div class="text-sm text-gray-600 dark:text-gray-400 opacity-60 mb-2">@ {item.issuer}</div>
                  {item.description && (
                    <p class="text-sm text-gray-700 dark:text-gray-300 opacity-80">{item.description}</p>
                  )}
                </>
              )}

              {item.type === 'speaking' && (
                <>
                  <div class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-1">{item.title}</div>
                  <div class="text-sm text-gray-600 dark:text-gray-400 opacity-60 mb-3">@ {item.venue}</div>
                  <div class="flex gap-2">
                    {item.links.repo ? (
                      <a
                        class="opacity-20 dark:opacity-40 hover:opacity-100 transition-opacity"
                        href={item.links.repo}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <Icon name="lucide:github" class="w-3.5 h-3.5" />
                      </a>
                    ) : (
                      <div class="opacity-10 dark:opacity-20">
                        <Icon name="lucide:github" class="w-3.5 h-3.5" />
                      </div>
                    )}
                    {item.links.info ? (
                      <a
                        class="opacity-20 dark:opacity-40 hover:opacity-100 transition-opacity"
                        href={item.links.info}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <Icon name="lucide:link" class="w-3.5 h-3.5" />
                      </a>
                    ) : (
                      <div class="opacity-10 dark:opacity-20">
                        <Icon name="lucide:link" class="w-3.5 h-3.5" />
                      </div>
                    )}
                    {item.links.recording ? (
                      <a
                        class="opacity-20 dark:opacity-40 hover:opacity-100 transition-opacity"
                        href={item.links.recording}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <Icon name="lucide:play" class="w-3.5 h-3.5" />
                      </a>
                    ) : (
                      <div class="opacity-10 dark:opacity-20">
                        <Icon name="lucide:video" class="w-3.5 h-3.5" />
                      </div>
                    )}
                    {item.links.twitter && (
                      <a
                        class="opacity-20 dark:opacity-40 hover:opacity-100 transition-opacity"
                        href={item.links.twitter}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        <Icon name="lucide:twitter" class="w-3.5 h-3.5" />
                      </a>
                    )}
                  </div>
                </>
              )}

              {item.type === 'personal' && (
                <>
                  <div class="text-lg font-semibold text-gray-900 dark:text-gray-100 mb-1">{item.title}</div>
                  {item.description && (
                    <p class="text-sm text-gray-700 dark:text-gray-300 opacity-80">{item.description}</p>
                  )}
                </>
              )}
            </div>
          </div>
        </div>
      )
    })
  }
</div>

<script is:inline define:vars={{ items }}>
  {
    // Load saved state from localStorage
    const savedFilters = localStorage.getItem('timeline-filters')
    const filters = savedFilters
      ? new Set(JSON.parse(savedFilters))
      : new Set(['experience', 'education', 'achievement', 'speaking', 'personal'])

    const savedTimeScale = localStorage.getItem('timeline-time-scale')
    let timeScaleMode = savedTimeScale === 'true'

    // Parse date helper
    function parseDate(dateStr) {
      if (dateStr === 'Present') return new Date()
      const monthYear = dateStr.match(/^([A-Za-z]+)\s+(\d{4})$/)
      if (monthYear) {
        return new Date(`${monthYear[1]} 1, ${monthYear[2]}`)
      }
      const year = dateStr.match(/^\d{4}$/)
      if (year) {
        return new Date(`${dateStr}-01-01`)
      }
      return new Date(dateStr)
    }

    function getItemDate(item) {
      if (item.type === 'achievement' || item.type === 'speaking' || item.type === 'personal') {
        return parseDate(item.date)
      }
      return parseDate(item.startDate)
    }

    function updateTimelinePositions() {
      const timelineItems = document.querySelectorAll('.timeline-item')
      const svg = document.getElementById('timeline-svg')

      if (!timeScaleMode) {
        // Reset to regular layout
        timelineItems.forEach((item, index) => {
          item.style.marginTop = ''
          item.style.minHeight = '180px'
        })
        setTimeout(updateSVGLines, 50)
        return
      }

      // Time scale mode: calculate positions based on actual dates
      const dates = items.map(getItemDate)
      const minDate = Math.min(...dates.map((d) => d.getTime()))
      const maxDate = Math.max(...dates.map((d) => d.getTime()))
      const totalDays = (maxDate - minDate) / (1000 * 60 * 60 * 24)
      const pixelsPerDay = 1

      let currentY = 0
      timelineItems.forEach((item, index) => {
        if (index === 0) {
          item.style.marginTop = '0'
          item.style.minHeight = '40px'
        } else {
          const prevDate = dates[index - 1].getTime()
          const currentDate = dates[index].getTime()
          const daysDiff = (prevDate - currentDate) / (1000 * 60 * 60 * 24)
          const spacing = Math.max(40, daysDiff * pixelsPerDay)

          currentY += spacing
          item.style.marginTop = `${spacing}px`
          item.style.minHeight = '40px'
        }
      })

      setTimeout(updateSVGLines, 50)
    }

    function updateSVGLines() {
      const timelineItems = document.querySelectorAll('.timeline-item')
      const container = timelineItems[0]?.parentElement
      if (!container) return

      // Get all visible items with their positions
      const visibleItems = []
      timelineItems.forEach((item, idx) => {
        if (item.style.display !== 'none') {
          const nodeLink = item.querySelector('.timeline-node-link')
          if (nodeLink) {
            const itemRect = item.getBoundingClientRect()
            const containerRect = container.getBoundingClientRect()
            // Position relative to container top, plus offset to node center (top-2 = 8px, + 16px node center)
            const relativeY = itemRect.top - containerRect.top + 24
            visibleItems.push({ originalIndex: idx, y: relativeY })
          }
        }
      })

      // Update each line to connect consecutive visible items
      const lines = document.querySelectorAll('.timeline-line')
      lines.forEach((line) => {
        const lineIndex = parseInt(line.getAttribute('data-index'))

        // Find the position in visible items array
        const currentIdx = visibleItems.findIndex((item) => item.originalIndex === lineIndex)

        if (currentIdx !== -1 && currentIdx < visibleItems.length - 1) {
          // Connect this visible item to the next visible item
          const y1 = visibleItems[currentIdx].y
          const y2 = visibleItems[currentIdx + 1].y

          line.setAttribute('y1', y1.toString())
          line.setAttribute('y2', y2.toString())
          line.style.display = ''
        } else {
          line.style.display = 'none'
        }
      })
    }

    function updateTimeline() {
      const timelineItems = document.querySelectorAll('.timeline-item')

      timelineItems.forEach((item) => {
        const type = item.getAttribute('data-type')
        if (filters.has(type)) {
          item.style.display = ''
        } else {
          item.style.display = 'none'
        }
      })

      // Update button styles
      const buttons = document.querySelectorAll('.timeline-filter')
      buttons.forEach((button) => {
        const type = button.getAttribute('data-type')
        if (filters.has(type)) {
          button.classList.remove('opacity-40')
        } else {
          button.classList.add('opacity-40')
        }
      })

      // Save filters to localStorage
      localStorage.setItem('timeline-filters', JSON.stringify(Array.from(filters)))

      // Recalculate lines after filtering
      setTimeout(updateSVGLines, 50)
    }

    // Filter toggle handlers
    document.querySelectorAll('.timeline-filter').forEach((button) => {
      button.addEventListener('click', (e) => {
        const type = button.getAttribute('data-type')

        if (e.altKey) {
          filters.clear()
          filters.add(type)
        } else {
          if (filters.has(type)) {
            if (filters.size > 1) {
              filters.delete(type)
            }
          } else {
            filters.add(type)
          }
        }

        updateTimeline()
      })
    })

    // Time scale toggle handler
    const timeScaleToggle = document.getElementById('time-scale-toggle')
    if (timeScaleToggle) {
      // Set initial state based on saved preference
      if (timeScaleMode) {
        timeScaleToggle.classList.remove('opacity-40')
        timeScaleToggle.classList.add('opacity-100')
      }

      timeScaleToggle.addEventListener('click', () => {
        timeScaleMode = !timeScaleMode

        // Save to localStorage
        localStorage.setItem('timeline-time-scale', timeScaleMode.toString())

        if (timeScaleMode) {
          timeScaleToggle.classList.remove('opacity-40')
          timeScaleToggle.classList.add('opacity-100')
        } else {
          timeScaleToggle.classList.remove('opacity-100')
          timeScaleToggle.classList.add('opacity-40')
        }
        updateTimelinePositions()
      })
    }

    updateTimeline()

    // Apply saved time scale mode on initial load
    if (timeScaleMode) {
      updateTimelinePositions()
    }

    // Handle clicking anchored nodes to unselect them
    function updateAnchoredState() {
      const currentHash = window.location.hash.substring(1)
      document.querySelectorAll('.timeline-item').forEach((item) => {
        if (item.id === currentHash && currentHash) {
          item.classList.add('is-anchored')
        } else {
          item.classList.remove('is-anchored')
        }
      })
    }

    document.querySelectorAll('.timeline-node-link').forEach((link) => {
      link.addEventListener('click', (e) => {
        const targetId = link.getAttribute('href').substring(1) // Remove the #
        const currentHash = window.location.hash.substring(1)

        if (currentHash === targetId) {
          e.preventDefault()
          // Clear all anchored states
          document.querySelectorAll('.timeline-item').forEach((item) => {
            item.classList.remove('is-anchored')
          })
          history.pushState(null, '', window.location.pathname + window.location.search)
        } else {
          // Will be handled by hashchange event
          setTimeout(updateAnchoredState, 0)
        }
      })
    })

    // Update anchored state on hash change
    window.addEventListener('hashchange', updateAnchoredState)

    // Initial anchored state
    updateAnchoredState()

    // Recalculate line positions on window resize
    window.addEventListener('resize', () => {
      setTimeout(updateSVGLines, 100)
    })

    // Initial line positioning - need to wait for layout
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        updateSVGLines()
      })
    })

    // Help overlay handlers
    const helpButton = document.getElementById('filter-help')
    const helpOverlay = document.getElementById('filter-help-overlay')
    const helpClose = document.getElementById('filter-help-close')

    if (helpButton && helpOverlay && helpClose) {
      helpButton.addEventListener('click', () => {
        helpOverlay.style.display = 'block'
        helpOverlay.classList.remove('hidden')
      })

      const closeHelp = () => {
        helpOverlay.style.display = 'none'
        helpOverlay.classList.add('hidden')
      }

      helpClose.addEventListener('click', closeHelp)
      helpOverlay.addEventListener('click', (e) => {
        if (e.target === helpOverlay) {
          closeHelp()
        }
      })

      // Close on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && helpOverlay.style.display === 'block') {
          closeHelp()
        }
      })
    }

    document.addEventListener('astro:page-load', () => {
      updateTimeline()
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          updateSVGLines()
        })
      })
    })
  }
</script>
